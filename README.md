# JS-algorithm
## 一、排序
### 1、冒泡排序

**冒泡排序：** 其主要思想是在带排序序列中选两相邻的数字，如果反序则交换，直到没有反序为止。

![](https://user-gold-cdn.xitu.io/2019/6/13/16b50e0885655016?imageslim)

**算法描述：** 

* 比较相邻的两元素，如果第一个比第二个大，就交换它们两个；
* 对每一对相邻元素做统一功过，从第一对到最后一对
* 针对所有元素重复以上步骤，除了最后一个
* 重复以上步骤，直到排序完成

**代码实现：**

 见`bubbleSort.js`

**复杂度以及稳定性：**

时间复杂度：平均 O(n^2) 最好 O(n)  最坏 O(n^2)

空间复杂度：O(1)

稳定性：稳定

### 2、快速排序

**快速排序：** 记录的比较和移动是从两端向中间进行的，数值大的记录一次就能从前面移动到后面，数值小的记录一次就能从后面移动到前面，从而减少了总的比较次数和移动次数。

![](https://user-gold-cdn.xitu.io/2019/6/13/16b511f9b8ce84a3?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

**算法描述：** 

* 从数列中挑出一个元素，称为“基准”；
* 重新排序数列，所有元素都比基准小的放在基准前面，所有元素比基准大的挡在基准后面。在这个分区退出后，该基准就位于数列的中间位置，这个称为分区操作；
* 递归地把小于基准的子数列和大于基准的子数列进行排序。

**代码实现：**

见`quickSort.js`

**复杂度及稳定性：**

时间复杂度：平均 O(nlogn) 最好 O(nlogn) 最坏 O(n^2) 

空间复杂度：O(logn)

稳定性：不稳定

### 3、插入排序

**插入排序：** 每次将一个待排序的数字按其关键码的大小插入到一个已排好的有序序列中，直到全部数字排好序。

![](https://user-gold-cdn.xitu.io/2019/6/13/16b51202f076f948?imageslim)

**算法描述：**

* 从第一个元素开始，该元素被认为已经排好序；
* 取出下一个元素，在已经排好序的元素序列中从后向前扫描；
* 如果该元素大于新元素，将该元素移到下一位置；
* 重复步骤3，直到找到已排序的元素小于或等于新元素的位置；
* 将新元素插入到该位置后；
* 重复步骤2～5

**代码实现：**

见`insertSort.js`

**复杂度及稳定性：**

时间复杂度：平均 O(n^2) 最好 O(n) 最坏 O(n^2)

空间复杂度：O(1)

稳定性：稳定